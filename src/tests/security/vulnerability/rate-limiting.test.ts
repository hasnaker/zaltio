/**
 * Rate Limiting Security Tests
 * Tests for rate limiting and DDoS protection
 * 
 * @security-test
 * @owasp A04:2021 - Insecure Design
 * @severity HIGH
 */

import * as crypto from 'crypto';
import * as fc from 'fast-check';

// Token bucket rate limiter
class TokenBucketRateLimiter {
  private buckets: Map<string, { tokens: number; lastRefill: number }> = new Map();
  private readonly maxTokens: number;
  private readonly refillRate: number; // tokens per second
  private readonly refillInterval: number; // ms

  constructor(config: { maxTokens: number; refillRate: number }) {
    this.maxTokens = config.maxTokens;
    this.refillRate = config.refillRate;
    this.refillInterval = 1000 / config.refillRate;
  }

  consume(identifier: string, tokens: number = 1): RateLimitResult {
    const now = Date.now();
    let bucket = this.buckets.get(identifier);

    if (!bucket) {
      bucket = { tokens: this.maxTokens, lastRefill: now };
      this.buckets.set(identifier, bucket);
    }

    // Refill tokens
    const timePassed = now - bucket.lastRefill;
    const tokensToAdd = Math.floor(timePassed / this.refillInterval);
    bucket.tokens = Math.min(this.maxTokens, bucket.tokens + tokensToAdd);
    bucket.lastRefill = now;

    // Check if enough tokens
    if (bucket.tokens >= tokens) {
      bucket.tokens -= tokens;
      return {
        allowed: true,
        remaining: bucket.tokens,
        resetAt: now + (this.maxTokens - bucket.tokens) * this.refillInterval
      };
    }

    return {
      allowed: false,
      remaining: bucket.tokens,
      resetAt: now + (tokens - bucket.tokens) * this.refillInterval,
      retryAfter: Math.ceil((tokens - bucket.tokens) * this.refillInterval / 1000)
    };
  }
}

interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetAt: number;
  retryAfter?: number;
}


// Sliding window rate limiter
class SlidingWindowRateLimiter {
  private windows: Map<string, number[]> = new Map();
  private readonly windowSize: number; // ms
  private readonly maxRequests: number;

  constructor(config: { windowSize: number; maxRequests: number }) {
    this.windowSize = config.windowSize;
    this.maxRequests = config.maxRequests;
  }

  check(identifier: string): RateLimitResult {
    const now = Date.now();
    let timestamps = this.windows.get(identifier) || [];

    // Remove old timestamps
    timestamps = timestamps.filter(t => now - t < this.windowSize);

    if (timestamps.length >= this.maxRequests) {
      const oldestTimestamp = Math.min(...timestamps);
      const resetAt = oldestTimestamp + this.windowSize;
      return {
        allowed: false,
        remaining: 0,
        resetAt,
        retryAfter: Math.ceil((resetAt - now) / 1000)
      };
    }

    timestamps.push(now);
    this.windows.set(identifier, timestamps);

    return {
      allowed: true,
      remaining: this.maxRequests - timestamps.length,
      resetAt: now + this.windowSize
    };
  }
}

// Adaptive rate limiter (adjusts based on behavior)
class AdaptiveRateLimiter {
  private userBehavior: Map<string, UserBehavior> = new Map();
  private readonly baseLimit: number;
  private readonly windowSize: number;

  constructor(config: { baseLimit: number; windowSize: number }) {
    this.baseLimit = config.baseLimit;
    this.windowSize = config.windowSize;
  }

  check(identifier: string, requestInfo: RequestInfo): AdaptiveRateLimitResult {
    const now = Date.now();
    let behavior = this.userBehavior.get(identifier);

    if (!behavior) {
      behavior = {
        requests: [],
        trustScore: 1.0,
        flags: []
      };
      this.userBehavior.set(identifier, behavior);
    }

    // Clean old requests
    behavior.requests = behavior.requests.filter(r => now - r.timestamp < this.windowSize);

    // Analyze behavior
    const suspiciousPatterns = this.detectSuspiciousPatterns(behavior, requestInfo);
    if (suspiciousPatterns.length > 0) {
      behavior.trustScore = Math.max(0.1, behavior.trustScore - 0.1);
      behavior.flags.push(...suspiciousPatterns);
    }

    // Calculate effective limit based on trust score
    const effectiveLimit = Math.floor(this.baseLimit * behavior.trustScore);

    if (behavior.requests.length >= effectiveLimit) {
      return {
        allowed: false,
        remaining: 0,
        trustScore: behavior.trustScore,
        flags: behavior.flags,
        effectiveLimit
      };
    }

    behavior.requests.push({
      timestamp: now,
      endpoint: requestInfo.endpoint,
      method: requestInfo.method
    });

    return {
      allowed: true,
      remaining: effectiveLimit - behavior.requests.length,
      trustScore: behavior.trustScore,
      flags: behavior.flags,
      effectiveLimit
    };
  }

  private detectSuspiciousPatterns(behavior: UserBehavior, request: RequestInfo): string[] {
    const patterns: string[] = [];

    // Check for rapid requests
    const recentRequests = behavior.requests.filter(r => Date.now() - r.timestamp < 1000);
    if (recentRequests.length > 10) {
      patterns.push('RAPID_REQUESTS');
    }

    // Check for endpoint scanning
    const uniqueEndpoints = new Set(behavior.requests.map(r => r.endpoint));
    if (uniqueEndpoints.size > 50) {
      patterns.push('ENDPOINT_SCANNING');
    }

    // Check for unusual methods
    if (['DELETE', 'PUT', 'PATCH'].includes(request.method)) {
      const methodCount = behavior.requests.filter(r => r.method === request.method).length;
      if (methodCount > 20) {
        patterns.push('EXCESSIVE_MUTATIONS');
      }
    }

    return patterns;
  }
}

interface UserBehavior {
  requests: Array<{ timestamp: number; endpoint: string; method: string }>;
  trustScore: number;
  flags: string[];
}

interface RequestInfo {
  endpoint: string;
  method: string;
  userAgent?: string;
}

interface AdaptiveRateLimitResult {
  allowed: boolean;
  remaining: number;
  trustScore: number;
  flags: string[];
  effectiveLimit: number;
}


// IP-based rate limiter with bypass detection
class IPRateLimiter {
  private ipLimits: Map<string, { count: number; blockedUntil?: number }> = new Map();
  private readonly maxRequests: number;
  private readonly windowMs: number;
  private readonly blockDuration: number;

  constructor(config: { maxRequests: number; windowMs: number; blockDuration: number }) {
    this.maxRequests = config.maxRequests;
    this.windowMs = config.windowMs;
    this.blockDuration = config.blockDuration;
  }

  check(ip: string, headers: Record<string, string>): IPRateLimitResult {
    // Detect bypass attempts
    const bypassAttempt = this.detectBypassAttempt(headers);
    if (bypassAttempt) {
      return {
        allowed: false,
        reason: bypassAttempt,
        blocked: true
      };
    }

    const now = Date.now();
    let limit = this.ipLimits.get(ip);

    // Check if blocked
    if (limit?.blockedUntil && limit.blockedUntil > now) {
      return {
        allowed: false,
        reason: 'IP temporarily blocked',
        blocked: true,
        retryAfter: Math.ceil((limit.blockedUntil - now) / 1000)
      };
    }

    if (!limit || (limit.blockedUntil && limit.blockedUntil <= now)) {
      limit = { count: 0 };
      this.ipLimits.set(ip, limit);
    }

    limit.count++;

    if (limit.count > this.maxRequests) {
      limit.blockedUntil = now + this.blockDuration;
      return {
        allowed: false,
        reason: 'Rate limit exceeded',
        blocked: true,
        retryAfter: Math.ceil(this.blockDuration / 1000)
      };
    }

    return {
      allowed: true,
      remaining: this.maxRequests - limit.count,
      blocked: false
    };
  }

  private detectBypassAttempt(headers: Record<string, string>): string | null {
    const spoofHeaders = [
      'X-Forwarded-For',
      'X-Real-IP',
      'X-Client-IP',
      'CF-Connecting-IP',
      'True-Client-IP',
      'X-Cluster-Client-IP'
    ];

    // Multiple IP headers = suspicious
    const presentHeaders = spoofHeaders.filter(h => headers[h]);
    if (presentHeaders.length > 2) {
      return 'Multiple IP spoofing headers detected';
    }

    // Check for localhost/internal IPs in forwarded headers
    const forwardedIP = headers['X-Forwarded-For']?.split(',')[0]?.trim();
    if (forwardedIP) {
      const internalPatterns = [
        /^127\./,
        /^10\./,
        /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
        /^192\.168\./,
        /^::1$/,
        /^localhost$/i
      ];

      if (internalPatterns.some(p => p.test(forwardedIP))) {
        return 'Internal IP in forwarded header - bypass attempt';
      }
    }

    return null;
  }
}

interface IPRateLimitResult {
  allowed: boolean;
  reason?: string;
  blocked: boolean;
  remaining?: number;
  retryAfter?: number;
}

describe('Rate Limiting Security Tests', () => {
  describe('Token Bucket Rate Limiter', () => {
    it('should allow requests within limit', () => {
      const limiter = new TokenBucketRateLimiter({ maxTokens: 10, refillRate: 1 });
      
      for (let i = 0; i < 10; i++) {
        const result = limiter.consume('user1');
        expect(result.allowed).toBe(true);
      }
    });

    it('should block requests exceeding limit', () => {
      const limiter = new TokenBucketRateLimiter({ maxTokens: 5, refillRate: 1 });
      
      // Exhaust tokens
      for (let i = 0; i < 5; i++) {
        limiter.consume('user2');
      }

      // Next request should be blocked
      const result = limiter.consume('user2');
      expect(result.allowed).toBe(false);
      expect(result.retryAfter).toBeDefined();
    });

    it('should refill tokens over time', async () => {
      const limiter = new TokenBucketRateLimiter({ maxTokens: 2, refillRate: 10 }); // 10 tokens/sec
      
      // Exhaust tokens
      limiter.consume('user3');
      limiter.consume('user3');
      
      // Wait for refill
      await new Promise(r => setTimeout(r, 200));
      
      // Should have tokens again
      const result = limiter.consume('user3');
      expect(result.allowed).toBe(true);
    });

    it('should track remaining tokens', () => {
      const limiter = new TokenBucketRateLimiter({ maxTokens: 10, refillRate: 1 });
      
      const result1 = limiter.consume('user4');
      expect(result1.remaining).toBe(9);
      
      const result2 = limiter.consume('user4');
      expect(result2.remaining).toBe(8);
    });
  });


  describe('Sliding Window Rate Limiter', () => {
    it('should enforce sliding window limits', () => {
      const limiter = new SlidingWindowRateLimiter({ windowSize: 60000, maxRequests: 5 });
      
      for (let i = 0; i < 5; i++) {
        const result = limiter.check('user1');
        expect(result.allowed).toBe(true);
      }

      const blocked = limiter.check('user1');
      expect(blocked.allowed).toBe(false);
    });

    it('should provide retry-after information', () => {
      const limiter = new SlidingWindowRateLimiter({ windowSize: 60000, maxRequests: 1 });
      
      limiter.check('user2');
      const result = limiter.check('user2');
      
      expect(result.allowed).toBe(false);
      expect(result.retryAfter).toBeDefined();
      expect(result.retryAfter).toBeGreaterThan(0);
    });
  });

  describe('Adaptive Rate Limiter', () => {
    it('should reduce limits for suspicious behavior', () => {
      const limiter = new AdaptiveRateLimiter({ baseLimit: 100, windowSize: 60000 });
      
      // Make many rapid requests
      for (let i = 0; i < 50; i++) {
        limiter.check('user1', { endpoint: `/api/endpoint${i}`, method: 'GET' });
      }

      const result = limiter.check('user1', { endpoint: '/api/test', method: 'GET' });
      
      // Trust score should be reduced
      expect(result.trustScore).toBeLessThan(1.0);
      expect(result.effectiveLimit).toBeLessThan(100);
    });

    it('should detect endpoint scanning', () => {
      const limiter = new AdaptiveRateLimiter({ baseLimit: 100, windowSize: 60000 });
      
      // Scan many different endpoints (need more than 50 unique)
      for (let i = 0; i < 55; i++) {
        limiter.check('scanner', { endpoint: `/api/v1/resource${i}`, method: 'GET' });
      }

      const result = limiter.check('scanner', { endpoint: '/api/test', method: 'GET' });
      // Should have either ENDPOINT_SCANNING or RAPID_REQUESTS flag
      expect(result.flags.length).toBeGreaterThan(0);
    });

    it('should detect excessive mutations', () => {
      const limiter = new AdaptiveRateLimiter({ baseLimit: 100, windowSize: 60000 });
      
      // Many DELETE requests (need more than 20)
      for (let i = 0; i < 25; i++) {
        limiter.check('attacker', { endpoint: `/api/users/${i}`, method: 'DELETE' });
      }

      const result = limiter.check('attacker', { endpoint: '/api/users/26', method: 'DELETE' });
      // Should have suspicious behavior flags
      expect(result.flags.length).toBeGreaterThan(0);
    });
  });

  describe('IP Rate Limiter with Bypass Detection', () => {
    it('should detect IP spoofing attempts', () => {
      const limiter = new IPRateLimiter({
        maxRequests: 100,
        windowMs: 60000,
        blockDuration: 300000
      });

      const result = limiter.check('1.2.3.4', {
        'X-Forwarded-For': '5.6.7.8',
        'X-Real-IP': '9.10.11.12',
        'X-Client-IP': '13.14.15.16'
      });

      expect(result.allowed).toBe(false);
      expect(result.reason).toContain('spoofing');
    });

    it('should detect localhost bypass attempts', () => {
      const limiter = new IPRateLimiter({
        maxRequests: 100,
        windowMs: 60000,
        blockDuration: 300000
      });

      const result = limiter.check('1.2.3.4', {
        'X-Forwarded-For': '127.0.0.1'
      });

      expect(result.allowed).toBe(false);
      expect(result.reason).toContain('bypass');
    });

    it('should block IPs after exceeding limit', () => {
      const limiter = new IPRateLimiter({
        maxRequests: 5,
        windowMs: 60000,
        blockDuration: 300000
      });

      // Exceed limit
      for (let i = 0; i < 6; i++) {
        limiter.check('attacker-ip', {});
      }

      const result = limiter.check('attacker-ip', {});
      expect(result.blocked).toBe(true);
      expect(result.retryAfter).toBeDefined();
    });
  });


  describe('DDoS Protection Patterns', () => {
    it('should handle burst traffic', () => {
      const limiter = new TokenBucketRateLimiter({ maxTokens: 100, refillRate: 10 });
      
      // Simulate burst
      let allowed = 0;
      let blocked = 0;
      
      for (let i = 0; i < 150; i++) {
        const result = limiter.consume('burst-user');
        if (result.allowed) allowed++;
        else blocked++;
      }

      expect(allowed).toBe(100); // Max tokens
      expect(blocked).toBe(50);
    });

    it('should isolate users from each other', () => {
      const limiter = new TokenBucketRateLimiter({ maxTokens: 5, refillRate: 1 });
      
      // User 1 exhausts their limit
      for (let i = 0; i < 5; i++) {
        limiter.consume('user1');
      }

      // User 2 should still have full quota
      const result = limiter.consume('user2');
      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(4);
    });

    it('should handle concurrent requests', async () => {
      const limiter = new SlidingWindowRateLimiter({ windowSize: 1000, maxRequests: 10 });
      
      // Simulate concurrent requests
      const results = await Promise.all(
        Array(15).fill(null).map(() => 
          Promise.resolve(limiter.check('concurrent-user'))
        )
      );

      const allowed = results.filter(r => r.allowed).length;
      const blocked = results.filter(r => !r.allowed).length;

      expect(allowed).toBe(10);
      expect(blocked).toBe(5);
    });
  });

  describe('Property-Based Rate Limiting Tests', () => {
    it('should never allow more than max requests', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 1, max: 100 }),
          fc.integer({ min: 1, max: 200 }),
          (maxRequests, totalRequests) => {
            const limiter = new SlidingWindowRateLimiter({
              windowSize: 60000,
              maxRequests
            });

            let allowed = 0;
            for (let i = 0; i < totalRequests; i++) {
              if (limiter.check('test-user').allowed) {
                allowed++;
              }
            }

            expect(allowed).toBeLessThanOrEqual(maxRequests);
          }
        ),
        { numRuns: 50 }
      );
    });

    it('should always provide valid retry-after when blocked', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 1, max: 10 }),
          (maxRequests) => {
            const limiter = new SlidingWindowRateLimiter({
              windowSize: 60000,
              maxRequests
            });

            // Exhaust limit
            for (let i = 0; i < maxRequests; i++) {
              limiter.check('exhaust-user');
            }

            // Next request should have valid retry-after
            const result = limiter.check('exhaust-user');
            expect(result.allowed).toBe(false);
            expect(result.retryAfter).toBeGreaterThan(0);
          }
        ),
        { numRuns: 20 }
      );
    });
  });

  describe('Rate Limit Headers', () => {
    it('should generate correct rate limit headers', () => {
      const limiter = new TokenBucketRateLimiter({ maxTokens: 100, refillRate: 10 });
      const result = limiter.consume('header-user');

      // Simulate header generation
      const headers = {
        'X-RateLimit-Limit': '100',
        'X-RateLimit-Remaining': result.remaining.toString(),
        'X-RateLimit-Reset': Math.ceil(result.resetAt / 1000).toString()
      };

      expect(headers['X-RateLimit-Limit']).toBe('100');
      expect(parseInt(headers['X-RateLimit-Remaining'])).toBeLessThan(100);
      expect(parseInt(headers['X-RateLimit-Reset'])).toBeGreaterThan(0);
    });
  });
});
