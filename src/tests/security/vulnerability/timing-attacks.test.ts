/**
 * Timing Attack Security Tests
 * Tests for timing-based side-channel vulnerabilities
 * 
 * @security-test
 * @owasp A02:2021 - Cryptographic Failures
 * @severity HIGH
 */

import * as crypto from 'crypto';
import * as fc from 'fast-check';

// Vulnerable string comparison (DO NOT USE IN PRODUCTION)
const vulnerableCompare = (a: string, b: string): boolean => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false; // Early exit reveals position
  }
  return true;
};

// Secure constant-time comparison
const secureCompare = (a: string, b: string): boolean => {
  if (a.length !== b.length) {
    // Still compare to prevent length-based timing
    const dummy = crypto.timingSafeEqual(
      Buffer.from(a.padEnd(Math.max(a.length, b.length), '\0')),
      Buffer.from(b.padEnd(Math.max(a.length, b.length), '\0'))
    );
    return false;
  }
  return crypto.timingSafeEqual(Buffer.from(a), Buffer.from(b));
};

// Timing-safe user lookup
class TimingSafeAuthenticator {
  private users: Map<string, { passwordHash: string; salt: string }> = new Map();
  private readonly fakeHash: string;
  private readonly fakeSalt: string;

  constructor() {
    // Pre-computed fake values for non-existent users
    this.fakeSalt = crypto.randomBytes(16).toString('hex');
    this.fakeHash = crypto.pbkdf2Sync('dummy', this.fakeSalt, 100000, 64, 'sha512').toString('hex');
  }

  addUser(username: string, password: string): void {
    const salt = crypto.randomBytes(16).toString('hex');
    const hash = crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex');
    this.users.set(username, { passwordHash: hash, salt });
  }

  // Timing-safe authentication
  authenticate(username: string, password: string): boolean {
    const user = this.users.get(username);
    
    // Use fake values for non-existent users to prevent timing attacks
    const salt = user?.salt || this.fakeSalt;
    const storedHash = user?.passwordHash || this.fakeHash;
    
    // Always compute hash even for non-existent users
    const inputHash = crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex');
    
    // Constant-time comparison
    const hashMatch = crypto.timingSafeEqual(
      Buffer.from(inputHash),
      Buffer.from(storedHash)
    );
    
    // Only return true if user exists AND hash matches
    return user !== undefined && hashMatch;
  }
}

// Token validation with timing safety
const validateTokenTimingSafe = (
  providedToken: string,
  storedToken: string
): boolean => {
  if (!providedToken || !storedToken) return false;
  
  // Pad to same length
  const maxLen = Math.max(providedToken.length, storedToken.length);
  const paddedProvided = providedToken.padEnd(maxLen, '\0');
  const paddedStored = storedToken.padEnd(maxLen, '\0');
  
  return crypto.timingSafeEqual(
    Buffer.from(paddedProvided),
    Buffer.from(paddedStored)
  );
};

// Rate limiter with timing protection
class TimingSafeRateLimiter {
  private attempts: Map<string, number[]> = new Map();
  private readonly windowMs = 60000; // 1 minute
  private readonly maxAttempts = 5;
  private readonly baseDelay = 100; // ms

  async checkLimit(identifier: string): Promise<{ allowed: boolean; retryAfter?: number }> {
    const now = Date.now();
    const attempts = this.attempts.get(identifier) || [];
    
    // Clean old attempts
    const recentAttempts = attempts.filter(t => now - t < this.windowMs);
    
    // Add artificial delay to prevent timing analysis
    const jitter = crypto.randomInt(0, 50);
    await this.delay(this.baseDelay + jitter);
    
    if (recentAttempts.length >= this.maxAttempts) {
      const oldestAttempt = Math.min(...recentAttempts);
      const retryAfter = Math.ceil((oldestAttempt + this.windowMs - now) / 1000);
      return { allowed: false, retryAfter };
    }
    
    recentAttempts.push(now);
    this.attempts.set(identifier, recentAttempts);
    
    return { allowed: true };
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// HMAC comparison
const compareHMAC = (
  message: string,
  providedSignature: string,
  secret: string
): boolean => {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(message)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(providedSignature),
    Buffer.from(expectedSignature)
  );
};

describe('Timing Attack Prevention Tests', () => {
  describe('String Comparison Timing', () => {
    it('should use constant-time comparison for secrets', () => {
      const secret = 'super_secret_token_12345';
      const correct = secret;
      const wrongFirst = 'Xuper_secret_token_12345';
      const wrongLast = 'super_secret_token_1234X';

      // Both should take similar time with secure compare
      expect(secureCompare(secret, correct)).toBe(true);
      expect(secureCompare(secret, wrongFirst)).toBe(false);
      expect(secureCompare(secret, wrongLast)).toBe(false);
    });

    it('should handle different length strings safely', () => {
      const secret = 'correct_password';
      const short = 'short';
      const long = 'this_is_a_very_long_password_attempt';

      expect(secureCompare(secret, short)).toBe(false);
      expect(secureCompare(secret, long)).toBe(false);
    });

    it('should detect vulnerable comparison patterns', () => {
      // This test documents the vulnerability - DO NOT use vulnerableCompare
      const secret = 'secret123';
      
      // Vulnerable compare exits early on mismatch
      expect(vulnerableCompare(secret, 'secret123')).toBe(true);
      expect(vulnerableCompare(secret, 'Xecret123')).toBe(false);
      expect(vulnerableCompare(secret, 'secret12X')).toBe(false);
    });
  });

  describe('Authentication Timing Safety', () => {
    let authenticator: TimingSafeAuthenticator;

    beforeEach(() => {
      authenticator = new TimingSafeAuthenticator();
      authenticator.addUser('validuser', 'correctpassword');
    });

    it('should authenticate valid credentials', () => {
      expect(authenticator.authenticate('validuser', 'correctpassword')).toBe(true);
    });

    it('should reject invalid password', () => {
      expect(authenticator.authenticate('validuser', 'wrongpassword')).toBe(false);
    });

    it('should reject non-existent user without timing leak', () => {
      // This should take similar time as checking a valid user
      expect(authenticator.authenticate('nonexistent', 'anypassword')).toBe(false);
    });

    it('should perform hash computation for non-existent users', () => {
      // Both calls should perform similar work
      const start1 = Date.now();
      authenticator.authenticate('validuser', 'wrongpassword');
      const time1 = Date.now() - start1;

      const start2 = Date.now();
      authenticator.authenticate('nonexistent', 'wrongpassword');
      const time2 = Date.now() - start2;

      // Times should be within reasonable range (allowing for system variance)
      // This is a weak test - real timing analysis requires statistical methods
      expect(Math.abs(time1 - time2)).toBeLessThan(100);
    });
  });

  describe('Token Validation Timing', () => {
    it('should validate tokens in constant time', () => {
      const validToken = crypto.randomBytes(32).toString('hex');
      
      expect(validateTokenTimingSafe(validToken, validToken)).toBe(true);
      expect(validateTokenTimingSafe('wrong', validToken)).toBe(false);
    });

    it('should handle empty tokens safely', () => {
      expect(validateTokenTimingSafe('', 'token')).toBe(false);
      expect(validateTokenTimingSafe('token', '')).toBe(false);
      expect(validateTokenTimingSafe('', '')).toBe(false);
    });

    it('should handle null/undefined safely', () => {
      expect(validateTokenTimingSafe(null as any, 'token')).toBe(false);
      expect(validateTokenTimingSafe('token', undefined as any)).toBe(false);
    });
  });

  describe('HMAC Verification', () => {
    const secret = 'webhook_secret_key';

    it('should verify valid HMAC signatures', () => {
      const message = '{"event":"user.created","data":{}}';
      const signature = crypto
        .createHmac('sha256', secret)
        .update(message)
        .digest('hex');

      expect(compareHMAC(message, signature, secret)).toBe(true);
    });

    it('should reject invalid HMAC signatures', () => {
      const message = '{"event":"user.created","data":{}}';
      const fakeSignature = crypto
        .createHmac('sha256', 'wrong_secret')
        .update(message)
        .digest('hex');

      expect(compareHMAC(message, fakeSignature, secret)).toBe(false);
    });

    it('should reject tampered messages', () => {
      const originalMessage = '{"event":"user.created","data":{}}';
      const tamperedMessage = '{"event":"user.deleted","data":{}}';
      const signature = crypto
        .createHmac('sha256', secret)
        .update(originalMessage)
        .digest('hex');

      expect(compareHMAC(tamperedMessage, signature, secret)).toBe(false);
    });
  });

  describe('Rate Limiter Timing Protection', () => {
    let rateLimiter: TimingSafeRateLimiter;

    beforeEach(() => {
      rateLimiter = new TimingSafeRateLimiter();
    });

    it('should allow requests within limit', async () => {
      const result = await rateLimiter.checkLimit('user1');
      expect(result.allowed).toBe(true);
    });

    it('should block requests exceeding limit', async () => {
      // Make 5 requests
      for (let i = 0; i < 5; i++) {
        await rateLimiter.checkLimit('user2');
      }

      // 6th request should be blocked
      const result = await rateLimiter.checkLimit('user2');
      expect(result.allowed).toBe(false);
      expect(result.retryAfter).toBeDefined();
    });

    it('should add jitter to prevent timing analysis', async () => {
      const times: number[] = [];

      for (let i = 0; i < 5; i++) {
        const start = Date.now();
        await rateLimiter.checkLimit(`user_${i}`);
        times.push(Date.now() - start);
      }

      // Check that times vary (jitter is working)
      const uniqueTimes = new Set(times);
      // With jitter, we expect some variation
      expect(times.every(t => t >= 100)).toBe(true); // Base delay
    });
  });

  describe('Enumeration Attack Prevention', () => {
    it('should not reveal user existence through timing', () => {
      const authenticator = new TimingSafeAuthenticator();
      authenticator.addUser('existinguser', 'password123');

      // Both should take similar time
      const measurements = {
        existing: [] as number[],
        nonExisting: [] as number[]
      };

      for (let i = 0; i < 10; i++) {
        const start1 = Date.now();
        authenticator.authenticate('existinguser', 'wrongpassword');
        measurements.existing.push(Date.now() - start1);

        const start2 = Date.now();
        authenticator.authenticate('nonexistentuser', 'wrongpassword');
        measurements.nonExisting.push(Date.now() - start2);
      }

      const avgExisting = measurements.existing.reduce((a, b) => a + b) / measurements.existing.length;
      const avgNonExisting = measurements.nonExisting.reduce((a, b) => a + b) / measurements.nonExisting.length;

      // Average times should be similar (within 50ms tolerance)
      expect(Math.abs(avgExisting - avgNonExisting)).toBeLessThan(50);
    });
  });

  describe('Property-Based Timing Tests', () => {
    it('should always use constant-time comparison regardless of input', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 100 }),
          fc.string({ minLength: 1, maxLength: 100 }),
          (a, b) => {
            // secureCompare should not throw
            const result = secureCompare(a, b);
            expect(typeof result).toBe('boolean');
            
            // Result should be correct
            expect(result).toBe(a === b);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should validate tokens consistently', () => {
      fc.assert(
        fc.property(
          fc.hexaString({ minLength: 32, maxLength: 64 }),
          fc.hexaString({ minLength: 32, maxLength: 64 }),
          (token1, token2) => {
            const result = validateTokenTimingSafe(token1, token2);
            expect(result).toBe(token1 === token2);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  describe('Cache Timing Attacks', () => {
    it('should not leak information through cache timing', () => {
      // Simulate a lookup that could leak through cache
      const sensitiveData = new Map<string, string>();
      sensitiveData.set('admin', 'secret_admin_data');
      sensitiveData.set('user', 'user_data');

      const secureLookup = (key: string): string | null => {
        // Always perform the same operations
        const result = sensitiveData.get(key);
        const dummy = sensitiveData.get('nonexistent'); // Dummy lookup
        
        // Use the dummy to prevent optimization
        if (dummy === 'impossible') {
          return dummy;
        }
        
        return result || null;
      };

      expect(secureLookup('admin')).toBe('secret_admin_data');
      expect(secureLookup('nonexistent')).toBe(null);
    });
  });
});
