/**
 * File Upload Security Tests
 * Tests for file upload vulnerabilities and bypass attempts
 * 
 * @security-test
 * @owasp A04:2021 - Insecure Design
 * @severity CRITICAL
 */

import * as crypto from 'crypto';
import * as fc from 'fast-check';

// File type validation
interface FileUpload {
  filename: string;
  mimeType: string;
  size: number;
  content: Buffer;
}

// Magic bytes for common file types
const MAGIC_BYTES: Record<string, Buffer[]> = {
  'image/jpeg': [Buffer.from([0xFF, 0xD8, 0xFF])],
  'image/png': [Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])],
  'image/gif': [Buffer.from([0x47, 0x49, 0x46, 0x38, 0x37, 0x61]), Buffer.from([0x47, 0x49, 0x46, 0x38, 0x39, 0x61])],
  'application/pdf': [Buffer.from([0x25, 0x50, 0x44, 0x46])],
  'application/zip': [Buffer.from([0x50, 0x4B, 0x03, 0x04])],
};

// Dangerous file extensions
const DANGEROUS_EXTENSIONS = [
  '.exe', '.dll', '.bat', '.cmd', '.ps1', '.vbs', '.js', '.jse',
  '.ws', '.wsf', '.msc', '.msi', '.msp', '.com', '.scr', '.hta',
  '.cpl', '.msc', '.jar', '.php', '.asp', '.aspx', '.jsp', '.py',
  '.rb', '.pl', '.sh', '.bash', '.cgi', '.htaccess', '.config'
];

// Double extension patterns
const DOUBLE_EXTENSION_PATTERNS = [
  /\.(jpg|png|gif|pdf)\.(php|asp|aspx|jsp|exe)$/i,
  /\.(jpg|png|gif|pdf)%00\.(php|asp|aspx|jsp|exe)$/i,
  /\.(jpg|png|gif|pdf)\x00\.(php|asp|aspx|jsp|exe)$/i,
];


class FileUploadValidator {
  private readonly allowedMimeTypes: string[];
  private readonly maxFileSize: number;
  private readonly allowedExtensions: string[];

  constructor(config: {
    allowedMimeTypes: string[];
    maxFileSize: number;
    allowedExtensions: string[];
  }) {
    this.allowedMimeTypes = config.allowedMimeTypes;
    this.maxFileSize = config.maxFileSize;
    this.allowedExtensions = config.allowedExtensions.map(e => e.toLowerCase());
  }

  validate(file: FileUpload): ValidationResult {
    const errors: string[] = [];

    // Check file size
    if (file.size > this.maxFileSize) {
      errors.push(`File size ${file.size} exceeds maximum ${this.maxFileSize}`);
    }

    // Check extension
    const extension = this.getExtension(file.filename);
    if (!this.allowedExtensions.includes(extension.toLowerCase())) {
      errors.push(`Extension ${extension} not allowed`);
    }

    // Check for dangerous extensions
    if (this.hasDangerousExtension(file.filename)) {
      errors.push('Dangerous file extension detected');
    }

    // Check for double extensions
    if (this.hasDoubleExtension(file.filename)) {
      errors.push('Double extension attack detected');
    }

    // Check MIME type
    if (!this.allowedMimeTypes.includes(file.mimeType)) {
      errors.push(`MIME type ${file.mimeType} not allowed`);
    }

    // Verify magic bytes match claimed MIME type
    if (!this.verifyMagicBytes(file.content, file.mimeType)) {
      errors.push('File content does not match claimed MIME type');
    }

    // Check for null bytes in filename
    if (this.hasNullBytes(file.filename)) {
      errors.push('Null byte injection detected in filename');
    }

    // Check for path traversal
    if (this.hasPathTraversal(file.filename)) {
      errors.push('Path traversal attempt detected');
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  private getExtension(filename: string): string {
    const parts = filename.split('.');
    return parts.length > 1 ? `.${parts[parts.length - 1]}` : '';
  }

  private hasDangerousExtension(filename: string): boolean {
    const lower = filename.toLowerCase();
    return DANGEROUS_EXTENSIONS.some(ext => lower.endsWith(ext));
  }

  private hasDoubleExtension(filename: string): boolean {
    return DOUBLE_EXTENSION_PATTERNS.some(pattern => pattern.test(filename));
  }

  private verifyMagicBytes(content: Buffer, mimeType: string): boolean {
    const expectedMagic = MAGIC_BYTES[mimeType];
    if (!expectedMagic) return true; // Unknown type, skip check

    return expectedMagic.some(magic => {
      if (content.length < magic.length) return false;
      return content.subarray(0, magic.length).equals(magic);
    });
  }

  private hasNullBytes(filename: string): boolean {
    return filename.includes('\x00') || filename.includes('%00');
  }

  private hasPathTraversal(filename: string): boolean {
    const patterns = ['../', '..\\', '%2e%2e%2f', '%2e%2e/', '..%2f', '%2e%2e%5c'];
    const lower = filename.toLowerCase();
    return patterns.some(p => lower.includes(p));
  }
}

interface ValidationResult {
  valid: boolean;
  errors: string[];
}


// Filename sanitizer
const sanitizeFilename = (filename: string): string => {
  // Remove path components
  let sanitized = filename.replace(/^.*[\\\/]/, '');
  
  // Remove null bytes
  sanitized = sanitized.replace(/\x00/g, '').replace(/%00/g, '');
  
  // Remove dangerous characters
  sanitized = sanitized.replace(/[<>:"/\\|?*\x00-\x1f]/g, '_');
  
  // Limit length
  if (sanitized.length > 255) {
    const ext = sanitized.split('.').pop() || '';
    sanitized = sanitized.substring(0, 250 - ext.length) + '.' + ext;
  }
  
  // Generate random name if empty
  if (!sanitized || sanitized === '.') {
    sanitized = crypto.randomBytes(16).toString('hex');
  }
  
  return sanitized;
};

// Content scanner for malicious patterns
const scanForMaliciousContent = (content: Buffer): ScanResult => {
  const issues: string[] = [];
  const contentStr = content.toString('utf8', 0, Math.min(content.length, 10000));

  // Check for PHP code
  if (/<\?php/i.test(contentStr) || /<\?=/i.test(contentStr)) {
    issues.push('PHP code detected');
  }

  // Check for JavaScript
  if (/<script/i.test(contentStr)) {
    issues.push('JavaScript code detected');
  }

  // Check for shell commands
  if (/#!/.test(contentStr)) {
    issues.push('Shell script detected');
  }

  // Check for SQL
  if (/SELECT\s+.*\s+FROM/i.test(contentStr) || /INSERT\s+INTO/i.test(contentStr)) {
    issues.push('SQL code detected');
  }

  // Check for XML external entities
  if (/<!ENTITY/i.test(contentStr) || /SYSTEM\s+["']/i.test(contentStr)) {
    issues.push('XXE attack pattern detected');
  }

  return {
    safe: issues.length === 0,
    issues
  };
};

interface ScanResult {
  safe: boolean;
  issues: string[];
}

describe('File Upload Security Tests', () => {
  describe('Extension Validation', () => {
    let validator: FileUploadValidator;

    beforeEach(() => {
      validator = new FileUploadValidator({
        allowedMimeTypes: ['image/jpeg', 'image/png', 'image/gif'],
        maxFileSize: 5 * 1024 * 1024,
        allowedExtensions: ['.jpg', '.jpeg', '.png', '.gif']
      });
    });

    it('should allow valid image files', () => {
      const file: FileUpload = {
        filename: 'photo.jpg',
        mimeType: 'image/jpeg',
        size: 1024,
        content: Buffer.from([0xFF, 0xD8, 0xFF, 0xE0])
      };

      const result = validator.validate(file);
      expect(result.valid).toBe(true);
    });

    it('should reject dangerous extensions', () => {
      const file: FileUpload = {
        filename: 'malware.exe',
        mimeType: 'application/octet-stream',
        size: 1024,
        content: Buffer.from([0x4D, 0x5A])
      };

      const result = validator.validate(file);
      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Dangerous file extension detected');
    });

    it('should detect double extension attacks', () => {
      const file: FileUpload = {
        filename: 'image.jpg.php',
        mimeType: 'image/jpeg',
        size: 1024,
        content: Buffer.from([0xFF, 0xD8, 0xFF])
      };

      const result = validator.validate(file);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('Double extension'))).toBe(true);
    });
  });


  describe('MIME Type Validation', () => {
    let validator: FileUploadValidator;

    beforeEach(() => {
      validator = new FileUploadValidator({
        allowedMimeTypes: ['image/jpeg', 'image/png'],
        maxFileSize: 5 * 1024 * 1024,
        allowedExtensions: ['.jpg', '.jpeg', '.png']
      });
    });

    it('should reject mismatched MIME type and content', () => {
      // Claims to be JPEG but has PNG magic bytes
      const file: FileUpload = {
        filename: 'fake.jpg',
        mimeType: 'image/jpeg',
        size: 1024,
        content: Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])
      };

      const result = validator.validate(file);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('does not match'))).toBe(true);
    });

    it('should reject executable disguised as image', () => {
      // EXE file with image extension
      const file: FileUpload = {
        filename: 'image.jpg',
        mimeType: 'image/jpeg',
        size: 1024,
        content: Buffer.from([0x4D, 0x5A, 0x90, 0x00]) // MZ header
      };

      const result = validator.validate(file);
      expect(result.valid).toBe(false);
    });
  });

  describe('Path Traversal Prevention', () => {
    let validator: FileUploadValidator;

    beforeEach(() => {
      validator = new FileUploadValidator({
        allowedMimeTypes: ['image/jpeg'],
        maxFileSize: 5 * 1024 * 1024,
        allowedExtensions: ['.jpg']
      });
    });

    it('should detect path traversal in filename', () => {
      const maliciousNames = [
        '../../../etc/passwd.jpg',
        '..\\..\\windows\\system32\\config.jpg',
        '%2e%2e%2f%2e%2e%2fetc/passwd.jpg',
        '....//....//etc/passwd.jpg'
      ];

      maliciousNames.forEach(filename => {
        const file: FileUpload = {
          filename,
          mimeType: 'image/jpeg',
          size: 1024,
          content: Buffer.from([0xFF, 0xD8, 0xFF])
        };

        const result = validator.validate(file);
        expect(result.valid).toBe(false);
        expect(result.errors.some(e => e.includes('Path traversal'))).toBe(true);
      });
    });
  });

  describe('Null Byte Injection', () => {
    let validator: FileUploadValidator;

    beforeEach(() => {
      validator = new FileUploadValidator({
        allowedMimeTypes: ['image/jpeg'],
        maxFileSize: 5 * 1024 * 1024,
        allowedExtensions: ['.jpg']
      });
    });

    it('should detect null byte injection', () => {
      const file: FileUpload = {
        filename: 'image.jpg\x00.php',
        mimeType: 'image/jpeg',
        size: 1024,
        content: Buffer.from([0xFF, 0xD8, 0xFF])
      };

      const result = validator.validate(file);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('Null byte'))).toBe(true);
    });

    it('should detect URL-encoded null byte', () => {
      const file: FileUpload = {
        filename: 'image.jpg%00.php',
        mimeType: 'image/jpeg',
        size: 1024,
        content: Buffer.from([0xFF, 0xD8, 0xFF])
      };

      const result = validator.validate(file);
      expect(result.valid).toBe(false);
    });
  });


  describe('Filename Sanitization', () => {
    it('should remove path components', () => {
      expect(sanitizeFilename('/etc/passwd')).toBe('passwd');
      expect(sanitizeFilename('C:\\Windows\\System32\\cmd.exe')).toBe('cmd.exe');
    });

    it('should remove null bytes', () => {
      expect(sanitizeFilename('file\x00.txt')).toBe('file.txt');
      expect(sanitizeFilename('file%00.txt')).toBe('file.txt');
    });

    it('should remove dangerous characters', () => {
      expect(sanitizeFilename('file<script>.txt')).toBe('file_script_.txt');
      expect(sanitizeFilename('file|cmd.txt')).toBe('file_cmd.txt');
    });

    it('should limit filename length', () => {
      const longName = 'a'.repeat(300) + '.jpg';
      const sanitized = sanitizeFilename(longName);
      expect(sanitized.length).toBeLessThanOrEqual(255);
      expect(sanitized.endsWith('.jpg')).toBe(true);
    });

    it('should handle empty filenames', () => {
      const sanitized = sanitizeFilename('');
      expect(sanitized.length).toBeGreaterThan(0);
    });
  });

  describe('Malicious Content Scanning', () => {
    it('should detect PHP code in files', () => {
      const content = Buffer.from('<?php echo "hacked"; ?>');
      const result = scanForMaliciousContent(content);
      expect(result.safe).toBe(false);
      expect(result.issues).toContain('PHP code detected');
    });

    it('should detect JavaScript in files', () => {
      const content = Buffer.from('<script>alert("xss")</script>');
      const result = scanForMaliciousContent(content);
      expect(result.safe).toBe(false);
      expect(result.issues).toContain('JavaScript code detected');
    });

    it('should detect shell scripts', () => {
      const content = Buffer.from('#!/bin/bash\nrm -rf /');
      const result = scanForMaliciousContent(content);
      expect(result.safe).toBe(false);
      expect(result.issues).toContain('Shell script detected');
    });

    it('should detect XXE patterns', () => {
      const content = Buffer.from('<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>');
      const result = scanForMaliciousContent(content);
      expect(result.safe).toBe(false);
      expect(result.issues).toContain('XXE attack pattern detected');
    });

    it('should pass clean binary content', () => {
      const content = Buffer.from([0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10]);
      const result = scanForMaliciousContent(content);
      expect(result.safe).toBe(true);
    });
  });

  describe('File Size Limits', () => {
    let validator: FileUploadValidator;

    beforeEach(() => {
      validator = new FileUploadValidator({
        allowedMimeTypes: ['image/jpeg'],
        maxFileSize: 1024 * 1024, // 1MB
        allowedExtensions: ['.jpg']
      });
    });

    it('should reject oversized files', () => {
      const file: FileUpload = {
        filename: 'large.jpg',
        mimeType: 'image/jpeg',
        size: 10 * 1024 * 1024, // 10MB
        content: Buffer.from([0xFF, 0xD8, 0xFF])
      };

      const result = validator.validate(file);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('exceeds maximum'))).toBe(true);
    });
  });

  describe('Property-Based File Upload Tests', () => {
    it('should always sanitize dangerous characters', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 100 }),
          (filename) => {
            const sanitized = sanitizeFilename(filename);
            
            // Should not contain dangerous characters
            expect(sanitized).not.toMatch(/[<>:"/\\|?*\x00-\x1f]/);
            
            // Should not be empty
            expect(sanitized.length).toBeGreaterThan(0);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should always detect path traversal patterns', () => {
      const validator = new FileUploadValidator({
        allowedMimeTypes: ['image/jpeg'],
        maxFileSize: 5 * 1024 * 1024,
        allowedExtensions: ['.jpg']
      });

      fc.assert(
        fc.property(
          fc.constantFrom('../', '..\\', '%2e%2e%2f', '%2e%2e/'),
          fc.string({ minLength: 1, maxLength: 20 }),
          (traversal, suffix) => {
            const file: FileUpload = {
              filename: `${traversal}${traversal}${suffix}.jpg`,
              mimeType: 'image/jpeg',
              size: 1024,
              content: Buffer.from([0xFF, 0xD8, 0xFF])
            };

            const result = validator.validate(file);
            expect(result.errors.some(e => e.includes('Path traversal'))).toBe(true);
          }
        ),
        { numRuns: 50 }
      );
    });
  });
});
