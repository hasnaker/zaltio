/**
 * Session Hijacking Security Tests
 * Tests for session security and hijacking prevention
 * 
 * @security-test
 * @owasp A07:2021 - Identification and Authentication Failures
 * @severity CRITICAL
 */

import * as crypto from 'crypto';
import * as fc from 'fast-check';

// Interfaces
interface SessionData {
  userId: string;
  createdAt: number;
  lastActivity: number;
  ipAddress: string;
  userAgent: string;
  fingerprint: string;
  isSecure: boolean;
}

interface SessionContext {
  ipAddress: string;
  userAgent: string;
  acceptLanguage?: string;
  isSecure: boolean;
}

interface ValidationResult {
  valid: boolean;
  reason: string;
}

interface CookieConfig {
  httpOnly: boolean;
  secure: boolean;
  sameSite: 'Strict' | 'Lax' | 'None' | null;
  domain?: string;
  path?: string;
}

interface SecurityIssue {
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  issue: string;
}


// Session Manager with security features
class SecureSessionManager {
  private sessions: Map<string, SessionData> = new Map();
  private readonly sessionIdLength = 32;
  private readonly maxSessionAge = 24 * 60 * 60 * 1000; // 24 hours
  private readonly maxIdleTime = 30 * 60 * 1000; // 30 minutes
  private readonly maxConcurrentSessions = 5;

  generateSessionId(): string {
    return crypto.randomBytes(this.sessionIdLength).toString('hex');
  }

  createSession(userId: string, context: SessionContext): string {
    const userSessions = this.getUserSessions(userId);
    if (userSessions.length >= this.maxConcurrentSessions) {
      const oldest = userSessions.sort((a, b) => a.createdAt - b.createdAt)[0];
      this.sessions.delete(oldest.sessionId);
    }

    const sessionId = this.generateSessionId();
    const fingerprint = this.generateFingerprint(context);

    this.sessions.set(sessionId, {
      userId,
      createdAt: Date.now(),
      lastActivity: Date.now(),
      ipAddress: context.ipAddress,
      userAgent: context.userAgent,
      fingerprint,
      isSecure: context.isSecure
    });

    return sessionId;
  }

  validateSession(sessionId: string, context: SessionContext): ValidationResult {
    const session = this.sessions.get(sessionId);

    if (!session) {
      return { valid: false, reason: 'SESSION_NOT_FOUND' };
    }

    if (Date.now() - session.createdAt > this.maxSessionAge) {
      this.sessions.delete(sessionId);
      return { valid: false, reason: 'SESSION_EXPIRED' };
    }

    if (Date.now() - session.lastActivity > this.maxIdleTime) {
      this.sessions.delete(sessionId);
      return { valid: false, reason: 'SESSION_IDLE_TIMEOUT' };
    }

    if (session.ipAddress !== context.ipAddress) {
      return { valid: false, reason: 'IP_ADDRESS_MISMATCH' };
    }

    if (session.userAgent !== context.userAgent) {
      return { valid: false, reason: 'USER_AGENT_MISMATCH' };
    }

    const currentFingerprint = this.generateFingerprint(context);
    if (session.fingerprint !== currentFingerprint) {
      return { valid: false, reason: 'FINGERPRINT_MISMATCH' };
    }

    session.lastActivity = Date.now();
    return { valid: true, reason: 'VALID' };
  }

  private generateFingerprint(context: SessionContext): string {
    const data = `${context.ipAddress}|${context.userAgent}|${context.acceptLanguage || ''}`;
    return crypto.createHash('sha256').update(data).digest('hex');
  }

  private getUserSessions(userId: string): Array<{ sessionId: string; createdAt: number }> {
    const sessions: Array<{ sessionId: string; createdAt: number }> = [];
    this.sessions.forEach((data, sessionId) => {
      if (data.userId === userId) {
        sessions.push({ sessionId, createdAt: data.createdAt });
      }
    });
    return sessions;
  }

  invalidateSession(sessionId: string): void {
    this.sessions.delete(sessionId);
  }

  invalidateAllUserSessions(userId: string): void {
    this.sessions.forEach((data, sessionId) => {
      if (data.userId === userId) {
        this.sessions.delete(sessionId);
      }
    });
  }

  rotateSessionId(oldSessionId: string, _context: SessionContext): string | null {
    const session = this.sessions.get(oldSessionId);
    if (!session) return null;

    const newSessionId = this.generateSessionId();
    this.sessions.set(newSessionId, { ...session, lastActivity: Date.now() });
    this.sessions.delete(oldSessionId);

    return newSessionId;
  }
}


// Session Fixation Prevention
const isSessionFixationVulnerable = (
  preAuthSessionId: string,
  postAuthSessionId: string
): boolean => {
  return preAuthSessionId === postAuthSessionId;
};

// Cookie Security Checker
const checkCookieSecurity = (cookie: CookieConfig): SecurityIssue[] => {
  const issues: SecurityIssue[] = [];

  if (!cookie.httpOnly) {
    issues.push({ severity: 'HIGH', issue: 'HttpOnly flag not set' });
  }
  if (!cookie.secure) {
    issues.push({ severity: 'HIGH', issue: 'Secure flag not set' });
  }
  if (!cookie.sameSite || cookie.sameSite === 'None') {
    issues.push({ severity: 'MEDIUM', issue: 'SameSite not set to Strict/Lax' });
  }
  if (cookie.domain && cookie.domain.startsWith('.')) {
    issues.push({ severity: 'MEDIUM', issue: 'Wildcard domain' });
  }

  return issues;
};

describe('Session Hijacking Prevention Tests', () => {
  describe('Session ID Security', () => {
    let sessionManager: SecureSessionManager;

    beforeEach(() => {
      sessionManager = new SecureSessionManager();
    });

    it('should generate cryptographically secure session IDs', () => {
      const sessionId = sessionManager.generateSessionId();
      expect(sessionId.length).toBe(64);
      expect(/^[a-f0-9]+$/.test(sessionId)).toBe(true);
    });

    it('should generate unique session IDs', () => {
      const ids = new Set<string>();
      for (let i = 0; i < 1000; i++) {
        const id = sessionManager.generateSessionId();
        expect(ids.has(id)).toBe(false);
        ids.add(id);
      }
    });

    it('should have sufficient entropy in session IDs', () => {
      const sessionId = sessionManager.generateSessionId();
      const entropy = sessionId.length * 4;
      expect(entropy).toBeGreaterThanOrEqual(128);
    });
  });

  describe('Session Fixation Prevention', () => {
    let sessionManager: SecureSessionManager;
    const context: SessionContext = {
      ipAddress: '192.168.1.1',
      userAgent: 'Mozilla/5.0',
      acceptLanguage: 'en-US',
      isSecure: true
    };

    beforeEach(() => {
      sessionManager = new SecureSessionManager();
    });

    it('should rotate session ID after authentication', () => {
      const preAuthSessionId = sessionManager.createSession('anonymous', context);
      const postAuthSessionId = sessionManager.rotateSessionId(preAuthSessionId, context);

      expect(postAuthSessionId).not.toBe(preAuthSessionId);
      expect(isSessionFixationVulnerable(preAuthSessionId, postAuthSessionId!)).toBe(false);
    });

    it('should invalidate old session after rotation', () => {
      const oldSessionId = sessionManager.createSession('user123', context);
      sessionManager.rotateSessionId(oldSessionId, context);

      const result = sessionManager.validateSession(oldSessionId, context);
      expect(result.valid).toBe(false);
      expect(result.reason).toBe('SESSION_NOT_FOUND');
    });
  });


  describe('Session Hijacking Detection', () => {
    let sessionManager: SecureSessionManager;
    const legitimateContext: SessionContext = {
      ipAddress: '192.168.1.1',
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
      acceptLanguage: 'en-US',
      isSecure: true
    };

    beforeEach(() => {
      sessionManager = new SecureSessionManager();
    });

    it('should detect IP address change', () => {
      const sessionId = sessionManager.createSession('user123', legitimateContext);
      const attackerContext: SessionContext = { ...legitimateContext, ipAddress: '10.0.0.1' };

      const result = sessionManager.validateSession(sessionId, attackerContext);
      expect(result.valid).toBe(false);
      expect(result.reason).toBe('IP_ADDRESS_MISMATCH');
    });

    it('should detect user agent change', () => {
      const sessionId = sessionManager.createSession('user123', legitimateContext);
      const attackerContext: SessionContext = { ...legitimateContext, userAgent: 'curl/7.64.1' };

      const result = sessionManager.validateSession(sessionId, attackerContext);
      expect(result.valid).toBe(false);
      expect(result.reason).toBe('USER_AGENT_MISMATCH');
    });

    it('should detect fingerprint mismatch', () => {
      const sessionId = sessionManager.createSession('user123', legitimateContext);
      const attackerContext: SessionContext = { ...legitimateContext, acceptLanguage: 'ru-RU' };

      const result = sessionManager.validateSession(sessionId, attackerContext);
      expect(result.valid).toBe(false);
      expect(result.reason).toBe('FINGERPRINT_MISMATCH');
    });
  });

  describe('Session Timeout', () => {
    let sessionManager: SecureSessionManager;
    const context: SessionContext = {
      ipAddress: '192.168.1.1',
      userAgent: 'Mozilla/5.0',
      isSecure: true
    };

    beforeEach(() => {
      sessionManager = new SecureSessionManager();
    });

    it('should expire sessions after max age', () => {
      const sessionId = sessionManager.createSession('user123', context);
      const sessions = (sessionManager as any).sessions;
      const session = sessions.get(sessionId);
      session.createdAt = Date.now() - 25 * 60 * 60 * 1000;

      const result = sessionManager.validateSession(sessionId, context);
      expect(result.valid).toBe(false);
      expect(result.reason).toBe('SESSION_EXPIRED');
    });

    it('should expire idle sessions', () => {
      const sessionId = sessionManager.createSession('user123', context);
      const sessions = (sessionManager as any).sessions;
      const session = sessions.get(sessionId);
      session.lastActivity = Date.now() - 31 * 60 * 1000;

      const result = sessionManager.validateSession(sessionId, context);
      expect(result.valid).toBe(false);
      expect(result.reason).toBe('SESSION_IDLE_TIMEOUT');
    });
  });

  describe('Concurrent Session Limits', () => {
    let sessionManager: SecureSessionManager;
    const context: SessionContext = {
      ipAddress: '192.168.1.1',
      userAgent: 'Mozilla/5.0',
      isSecure: true
    };

    beforeEach(() => {
      sessionManager = new SecureSessionManager();
    });

    it('should limit concurrent sessions per user', () => {
      const userId = 'user123';
      const sessionIds: string[] = [];

      for (let i = 0; i < 6; i++) {
        const id = sessionManager.createSession(userId, {
          ...context,
          ipAddress: `192.168.1.${i + 1}`
        });
        sessionIds.push(id);
      }

      const firstResult = sessionManager.validateSession(sessionIds[0], {
        ...context,
        ipAddress: '192.168.1.1'
      });
      expect(firstResult.valid).toBe(false);
    });

    it('should allow invalidating all user sessions', () => {
      const userId = 'user123';
      const sessionIds: string[] = [];

      for (let i = 0; i < 3; i++) {
        const id = sessionManager.createSession(userId, {
          ...context,
          ipAddress: `192.168.1.${i + 1}`
        });
        sessionIds.push(id);
      }

      sessionManager.invalidateAllUserSessions(userId);

      sessionIds.forEach((id, i) => {
        const result = sessionManager.validateSession(id, {
          ...context,
          ipAddress: `192.168.1.${i + 1}`
        });
        expect(result.valid).toBe(false);
      });
    });
  });


  describe('Cookie Security Configuration', () => {
    it('should identify insecure cookie configurations', () => {
      const insecureCookie: CookieConfig = {
        httpOnly: false,
        secure: false,
        sameSite: null
      };

      const issues = checkCookieSecurity(insecureCookie);
      expect(issues.length).toBeGreaterThan(0);
      expect(issues.some(i => i.severity === 'HIGH')).toBe(true);
    });

    it('should pass secure cookie configuration', () => {
      const secureCookie: CookieConfig = {
        httpOnly: true,
        secure: true,
        sameSite: 'Strict',
        path: '/'
      };

      const issues = checkCookieSecurity(secureCookie);
      expect(issues.length).toBe(0);
    });

    it('should warn about wildcard domains', () => {
      const wildcardCookie: CookieConfig = {
        httpOnly: true,
        secure: true,
        sameSite: 'Strict',
        domain: '.hsdcore.com'
      };

      const issues = checkCookieSecurity(wildcardCookie);
      expect(issues.some(i => i.issue.includes('Wildcard'))).toBe(true);
    });
  });

  describe('Property-Based Session Security', () => {
    it('should never validate sessions with wrong context', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1 }),
          fc.ipV4(),
          fc.ipV4(),
          (userId, ip1, ip2) => {
            fc.pre(ip1 !== ip2);

            const sessionManager = new SecureSessionManager();
            const context1: SessionContext = {
              ipAddress: ip1,
              userAgent: 'Mozilla/5.0',
              isSecure: true
            };
            const context2: SessionContext = {
              ipAddress: ip2,
              userAgent: 'Mozilla/5.0',
              isSecure: true
            };

            const sessionId = sessionManager.createSession(userId, context1);
            const result = sessionManager.validateSession(sessionId, context2);

            expect(result.valid).toBe(false);
          }
        ),
        { numRuns: 50 }
      );
    });

    it('should always generate unique session IDs', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 10, max: 100 }),
          (count) => {
            const sessionManager = new SecureSessionManager();
            const ids = new Set<string>();

            for (let i = 0; i < count; i++) {
              const id = sessionManager.generateSessionId();
              expect(ids.has(id)).toBe(false);
              ids.add(id);
            }
          }
        ),
        { numRuns: 20 }
      );
    });
  });
});
