/**
 * Business Logic Vulnerability Tests
 * Tests for business logic flaws and abuse scenarios
 * 
 * @security-test
 * @owasp A04:2021 - Insecure Design
 * @severity HIGH
 */

import * as fc from 'fast-check';

// Account state machine
type AccountState = 'pending' | 'active' | 'suspended' | 'deleted';
type AccountAction = 'verify' | 'suspend' | 'reactivate' | 'delete' | 'restore';

const validTransitions: Record<AccountState, AccountAction[]> = {
  pending: ['verify', 'delete'],
  active: ['suspend', 'delete'],
  suspended: ['reactivate', 'delete'],
  deleted: ['restore']
};

const transitionTo: Record<AccountAction, AccountState> = {
  verify: 'active',
  suspend: 'suspended',
  reactivate: 'active',
  delete: 'deleted',
  restore: 'pending'
};

class AccountStateMachine {
  private state: AccountState = 'pending';
  private history: Array<{ from: AccountState; action: AccountAction; to: AccountState }> = [];

  getState(): AccountState {
    return this.state;
  }

  canTransition(action: AccountAction): boolean {
    return validTransitions[this.state].includes(action);
  }

  transition(action: AccountAction): { success: boolean; error?: string } {
    if (!this.canTransition(action)) {
      return { 
        success: false, 
        error: `Cannot ${action} from ${this.state} state` 
      };
    }

    const from = this.state;
    this.state = transitionTo[action];
    this.history.push({ from, action, to: this.state });

    return { success: true };
  }
}


// Rate limit bypass detection
class RateLimitBypassDetector {
  private requests: Map<string, number[]> = new Map();
  private readonly windowMs = 60000;
  private readonly maxRequests = 100;

  checkRequest(identifier: string, headers: Record<string, string>): {
    allowed: boolean;
    bypassed: boolean;
    reason?: string;
  } {
    // Check for bypass attempts
    const bypassAttempt = this.detectBypassAttempt(headers);
    if (bypassAttempt) {
      return { allowed: false, bypassed: true, reason: bypassAttempt };
    }

    const now = Date.now();
    const requests = this.requests.get(identifier) || [];
    const recentRequests = requests.filter(t => now - t < this.windowMs);

    if (recentRequests.length >= this.maxRequests) {
      return { allowed: false, bypassed: false, reason: 'Rate limit exceeded' };
    }

    recentRequests.push(now);
    this.requests.set(identifier, recentRequests);
    return { allowed: true, bypassed: false };
  }

  private detectBypassAttempt(headers: Record<string, string>): string | null {
    // Check for IP spoofing headers
    const spoofHeaders = ['X-Forwarded-For', 'X-Real-IP', 'X-Client-IP', 'CF-Connecting-IP'];
    const suspiciousHeaders = spoofHeaders.filter(h => headers[h]);
    
    if (suspiciousHeaders.length > 1) {
      return 'Multiple IP headers detected - possible bypass attempt';
    }

    // Check for localhost bypass
    const clientIP = headers['X-Forwarded-For'] || headers['X-Real-IP'];
    if (clientIP && ['127.0.0.1', 'localhost', '::1'].includes(clientIP)) {
      return 'Localhost IP in forwarded header - possible bypass attempt';
    }

    return null;
  }
}

// Privilege escalation detector
interface User {
  id: string;
  role: 'user' | 'admin' | 'superadmin';
  permissions: string[];
}

class PrivilegeEscalationDetector {
  private roleHierarchy: Record<string, number> = {
    user: 1,
    admin: 2,
    superadmin: 3
  };

  checkEscalation(
    actor: User,
    targetRole: string,
    action: 'assign' | 'modify'
  ): { allowed: boolean; reason?: string } {
    const actorLevel = this.roleHierarchy[actor.role] || 0;
    const targetLevel = this.roleHierarchy[targetRole] || 0;

    // Cannot assign role higher than own
    if (targetLevel >= actorLevel) {
      return {
        allowed: false,
        reason: `Cannot ${action} role ${targetRole} - insufficient privileges`
      };
    }

    // Only superadmin can create admins
    if (targetRole === 'admin' && actor.role !== 'superadmin') {
      return {
        allowed: false,
        reason: 'Only superadmin can assign admin role'
      };
    }

    return { allowed: true };
  }

  checkSelfEscalation(user: User, newRole: string): boolean {
    // Users should never be able to escalate their own privileges
    const currentLevel = this.roleHierarchy[user.role] || 0;
    const newLevel = this.roleHierarchy[newRole] || 0;
    return newLevel > currentLevel;
  }
}


// Resource exhaustion detector
class ResourceExhaustionDetector {
  private resourceUsage: Map<string, { count: number; size: number }> = new Map();
  private readonly maxResourcesPerUser = 1000;
  private readonly maxSizePerUser = 100 * 1024 * 1024; // 100MB

  checkResourceCreation(
    userId: string,
    resourceSize: number
  ): { allowed: boolean; reason?: string } {
    const usage = this.resourceUsage.get(userId) || { count: 0, size: 0 };

    if (usage.count >= this.maxResourcesPerUser) {
      return { allowed: false, reason: 'Maximum resource count exceeded' };
    }

    if (usage.size + resourceSize > this.maxSizePerUser) {
      return { allowed: false, reason: 'Maximum storage quota exceeded' };
    }

    return { allowed: true };
  }

  recordResourceCreation(userId: string, resourceSize: number): void {
    const usage = this.resourceUsage.get(userId) || { count: 0, size: 0 };
    usage.count++;
    usage.size += resourceSize;
    this.resourceUsage.set(userId, usage);
  }
}

// Workflow bypass detector
interface WorkflowStep {
  name: string;
  required: boolean;
  completedAt?: Date;
}

class WorkflowEnforcer {
  private steps: WorkflowStep[] = [];

  constructor(stepNames: string[]) {
    this.steps = stepNames.map(name => ({ name, required: true }));
  }

  completeStep(stepName: string): { success: boolean; error?: string } {
    const stepIndex = this.steps.findIndex(s => s.name === stepName);
    
    if (stepIndex === -1) {
      return { success: false, error: 'Invalid step' };
    }

    // Check if previous required steps are completed
    for (let i = 0; i < stepIndex; i++) {
      if (this.steps[i].required && !this.steps[i].completedAt) {
        return { 
          success: false, 
          error: `Must complete ${this.steps[i].name} first` 
        };
      }
    }

    this.steps[stepIndex].completedAt = new Date();
    return { success: true };
  }

  canFinalize(): boolean {
    return this.steps.filter(s => s.required).every(s => s.completedAt);
  }
}

describe('Business Logic Vulnerability Tests', () => {
  describe('Account State Machine', () => {
    let account: AccountStateMachine;

    beforeEach(() => {
      account = new AccountStateMachine();
    });

    it('should start in pending state', () => {
      expect(account.getState()).toBe('pending');
    });

    it('should allow valid transitions', () => {
      expect(account.transition('verify').success).toBe(true);
      expect(account.getState()).toBe('active');
    });

    it('should reject invalid transitions', () => {
      const result = account.transition('reactivate');
      expect(result.success).toBe(false);
      expect(result.error).toContain('Cannot reactivate from pending');
    });

    it('should prevent direct state manipulation', () => {
      // Cannot go from pending to active without verification
      expect(account.canTransition('suspend')).toBe(false);
    });

    it('should enforce deletion workflow', () => {
      account.transition('verify');
      account.transition('delete');
      expect(account.getState()).toBe('deleted');
      
      // Can only restore from deleted
      expect(account.canTransition('verify')).toBe(false);
      expect(account.canTransition('restore')).toBe(true);
    });
  });


  describe('Rate Limit Bypass Detection', () => {
    let detector: RateLimitBypassDetector;

    beforeEach(() => {
      detector = new RateLimitBypassDetector();
    });

    it('should allow normal requests', () => {
      const result = detector.checkRequest('user1', {});
      expect(result.allowed).toBe(true);
      expect(result.bypassed).toBe(false);
    });

    it('should detect multiple IP headers', () => {
      const result = detector.checkRequest('user1', {
        'X-Forwarded-For': '1.2.3.4',
        'X-Real-IP': '5.6.7.8'
      });
      expect(result.bypassed).toBe(true);
      expect(result.reason).toContain('Multiple IP headers');
    });

    it('should detect localhost bypass attempts', () => {
      const result = detector.checkRequest('user1', {
        'X-Forwarded-For': '127.0.0.1'
      });
      expect(result.bypassed).toBe(true);
      expect(result.reason).toContain('Localhost IP');
    });

    it('should enforce rate limits', () => {
      // Make 100 requests
      for (let i = 0; i < 100; i++) {
        detector.checkRequest('user2', {});
      }

      // 101st should be blocked
      const result = detector.checkRequest('user2', {});
      expect(result.allowed).toBe(false);
      expect(result.reason).toContain('Rate limit exceeded');
    });
  });

  describe('Privilege Escalation Detection', () => {
    let detector: PrivilegeEscalationDetector;

    beforeEach(() => {
      detector = new PrivilegeEscalationDetector();
    });

    it('should prevent users from assigning admin roles', () => {
      const user: User = { id: '1', role: 'user', permissions: [] };
      const result = detector.checkEscalation(user, 'admin', 'assign');
      expect(result.allowed).toBe(false);
    });

    it('should allow admins to assign user roles', () => {
      const admin: User = { id: '1', role: 'admin', permissions: [] };
      const result = detector.checkEscalation(admin, 'user', 'assign');
      expect(result.allowed).toBe(true);
    });

    it('should prevent admins from creating other admins', () => {
      const admin: User = { id: '1', role: 'admin', permissions: [] };
      const result = detector.checkEscalation(admin, 'admin', 'assign');
      expect(result.allowed).toBe(false);
    });

    it('should allow superadmin to create admins', () => {
      const superadmin: User = { id: '1', role: 'superadmin', permissions: [] };
      const result = detector.checkEscalation(superadmin, 'admin', 'assign');
      expect(result.allowed).toBe(true);
    });

    it('should detect self-escalation attempts', () => {
      const user: User = { id: '1', role: 'user', permissions: [] };
      expect(detector.checkSelfEscalation(user, 'admin')).toBe(true);
      expect(detector.checkSelfEscalation(user, 'user')).toBe(false);
    });
  });

  describe('Resource Exhaustion Prevention', () => {
    let detector: ResourceExhaustionDetector;

    beforeEach(() => {
      detector = new ResourceExhaustionDetector();
    });

    it('should allow resource creation within limits', () => {
      const result = detector.checkResourceCreation('user1', 1024);
      expect(result.allowed).toBe(true);
    });

    it('should prevent exceeding resource count', () => {
      for (let i = 0; i < 1000; i++) {
        detector.recordResourceCreation('user2', 100);
      }

      const result = detector.checkResourceCreation('user2', 100);
      expect(result.allowed).toBe(false);
      expect(result.reason).toContain('Maximum resource count');
    });

    it('should prevent exceeding storage quota', () => {
      detector.recordResourceCreation('user3', 99 * 1024 * 1024);

      const result = detector.checkResourceCreation('user3', 2 * 1024 * 1024);
      expect(result.allowed).toBe(false);
      expect(result.reason).toContain('Maximum storage quota');
    });
  });


  describe('Workflow Bypass Prevention', () => {
    let workflow: WorkflowEnforcer;

    beforeEach(() => {
      workflow = new WorkflowEnforcer([
        'email_verification',
        'phone_verification',
        'identity_check',
        'approval'
      ]);
    });

    it('should enforce step order', () => {
      // Cannot skip to approval
      const result = workflow.completeStep('approval');
      expect(result.success).toBe(false);
      expect(result.error).toContain('Must complete email_verification first');
    });

    it('should allow completing steps in order', () => {
      expect(workflow.completeStep('email_verification').success).toBe(true);
      expect(workflow.completeStep('phone_verification').success).toBe(true);
      expect(workflow.completeStep('identity_check').success).toBe(true);
      expect(workflow.completeStep('approval').success).toBe(true);
    });

    it('should not allow finalization without all steps', () => {
      workflow.completeStep('email_verification');
      expect(workflow.canFinalize()).toBe(false);
    });

    it('should allow finalization when all steps complete', () => {
      workflow.completeStep('email_verification');
      workflow.completeStep('phone_verification');
      workflow.completeStep('identity_check');
      workflow.completeStep('approval');
      expect(workflow.canFinalize()).toBe(true);
    });
  });

  describe('Property-Based Business Logic Tests', () => {
    it('should never allow invalid state transitions', () => {
      fc.assert(
        fc.property(
          fc.constantFrom<AccountAction>('verify', 'suspend', 'reactivate', 'delete', 'restore'),
          fc.constantFrom<AccountAction>('verify', 'suspend', 'reactivate', 'delete', 'restore'),
          (action1, action2) => {
            const account = new AccountStateMachine();
            
            // Try first action
            const result1 = account.transition(action1);
            
            if (result1.success) {
              // Try second action
              const result2 = account.transition(action2);
              
              // If second action fails, it should be because it's invalid
              if (!result2.success) {
                expect(result2.error).toBeDefined();
              }
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should always detect self-escalation', () => {
      fc.assert(
        fc.property(
          fc.constantFrom<'user' | 'admin' | 'superadmin'>('user', 'admin', 'superadmin'),
          fc.constantFrom<'user' | 'admin' | 'superadmin'>('user', 'admin', 'superadmin'),
          (currentRole, targetRole) => {
            const detector = new PrivilegeEscalationDetector();
            const user: User = { id: '1', role: currentRole, permissions: [] };
            
            const roleHierarchy: Record<string, number> = {
              user: 1,
              admin: 2,
              superadmin: 3
            };

            const isEscalation = detector.checkSelfEscalation(user, targetRole);
            const expectedEscalation = roleHierarchy[targetRole] > roleHierarchy[currentRole];
            
            expect(isEscalation).toBe(expectedEscalation);
          }
        ),
        { numRuns: 50 }
      );
    });
  });

  describe('Race Condition Prevention', () => {
    it('should handle concurrent balance updates safely', async () => {
      let balance = 100;
      const lock = { locked: false };

      const safeWithdraw = async (amount: number): Promise<boolean> => {
        // Acquire lock
        while (lock.locked) {
          await new Promise(r => setTimeout(r, 1));
        }
        lock.locked = true;

        try {
          if (balance >= amount) {
            // Simulate processing delay
            await new Promise(r => setTimeout(r, 10));
            balance -= amount;
            return true;
          }
          return false;
        } finally {
          lock.locked = false;
        }
      };

      // Concurrent withdrawals
      const results = await Promise.all([
        safeWithdraw(60),
        safeWithdraw(60)
      ]);

      // Only one should succeed
      expect(results.filter(r => r).length).toBe(1);
      expect(balance).toBe(40);
    });
  });

  describe('Input Validation Edge Cases', () => {
    it('should handle negative values', () => {
      const detector = new ResourceExhaustionDetector();
      
      // Negative size should not bypass limits
      const result = detector.checkResourceCreation('user1', -1000);
      expect(result.allowed).toBe(true); // Allowed but should be validated elsewhere
    });

    it('should handle integer overflow attempts', () => {
      const detector = new ResourceExhaustionDetector();
      
      // Very large number
      const result = detector.checkResourceCreation('user1', Number.MAX_SAFE_INTEGER);
      expect(result.allowed).toBe(false);
    });
  });
});
