/**
 * JWT Security Tests
 * Tests for JWT vulnerabilities and attack vectors
 * 
 * @security-test
 * @owasp A02:2021 - Cryptographic Failures
 * @owasp A07:2021 - Identification and Authentication Failures
 * @severity CRITICAL
 */

import * as crypto from 'crypto';
import * as fc from 'fast-check';

// JWT structure
interface JWTHeader {
  alg: string;
  typ: string;
  kid?: string;
}

interface JWTPayload {
  sub: string;
  iat: number;
  exp: number;
  iss?: string;
  aud?: string;
  jti?: string;
  [key: string]: unknown;
}

// Base64URL encoding/decoding
const base64UrlEncode = (data: string | Buffer): string => {
  const base64 = Buffer.from(data).toString('base64');
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
};

const base64UrlDecode = (data: string): string => {
  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');
  const padding = base64.length % 4 === 0 ? '' : '='.repeat(4 - (base64.length % 4));
  return Buffer.from(base64 + padding, 'base64').toString('utf8');
};


// Secure JWT validator
class SecureJWTValidator {
  private readonly allowedAlgorithms = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'];
  private readonly publicKeys: Map<string, string> = new Map();
  private readonly issuer: string;
  private readonly audience: string;
  private readonly clockTolerance = 30; // seconds
  private readonly usedTokens: Set<string> = new Set(); // For replay protection

  constructor(config: { issuer: string; audience: string }) {
    this.issuer = config.issuer;
    this.audience = config.audience;
  }

  addPublicKey(kid: string, publicKey: string): void {
    this.publicKeys.set(kid, publicKey);
  }

  validate(token: string): ValidationResult {
    const errors: string[] = [];

    // Split token
    const parts = token.split('.');
    if (parts.length !== 3) {
      return { valid: false, errors: ['Invalid token format'] };
    }

    const [headerB64, payloadB64, signature] = parts;

    // Decode header
    let header: JWTHeader;
    try {
      header = JSON.parse(base64UrlDecode(headerB64));
    } catch {
      return { valid: false, errors: ['Invalid header encoding'] };
    }

    // Check algorithm
    if (!this.allowedAlgorithms.includes(header.alg)) {
      errors.push(`Algorithm ${header.alg} not allowed`);
    }

    // CRITICAL: Reject 'none' algorithm
    if (header.alg.toLowerCase() === 'none') {
      errors.push('Algorithm "none" is not allowed');
    }

    // CRITICAL: Reject symmetric algorithms when expecting asymmetric
    if (['HS256', 'HS384', 'HS512'].includes(header.alg)) {
      errors.push('Symmetric algorithms not allowed - possible algorithm confusion attack');
    }

    // Decode payload
    let payload: JWTPayload;
    try {
      payload = JSON.parse(base64UrlDecode(payloadB64));
    } catch {
      return { valid: false, errors: ['Invalid payload encoding'] };
    }

    // Check expiration
    const now = Math.floor(Date.now() / 1000);
    if (payload.exp && payload.exp + this.clockTolerance < now) {
      errors.push('Token has expired');
    }

    // Check not before
    if (payload.nbf && (payload.nbf as number) - this.clockTolerance > now) {
      errors.push('Token not yet valid');
    }

    // Check issued at (reject tokens from future)
    if (payload.iat && payload.iat - this.clockTolerance > now) {
      errors.push('Token issued in the future');
    }

    // Check issuer
    if (payload.iss !== this.issuer) {
      errors.push(`Invalid issuer: expected ${this.issuer}, got ${payload.iss}`);
    }

    // Check audience
    if (payload.aud !== this.audience) {
      errors.push(`Invalid audience: expected ${this.audience}, got ${payload.aud}`);
    }

    // Check for replay attack (if jti present)
    if (payload.jti) {
      if (this.usedTokens.has(payload.jti)) {
        errors.push('Token replay detected');
      } else {
        this.usedTokens.add(payload.jti);
      }
    }

    // Verify signature (simplified - in production use proper crypto)
    if (!signature || signature.length === 0) {
      errors.push('Missing signature');
    }

    return {
      valid: errors.length === 0,
      errors,
      payload: errors.length === 0 ? payload : undefined
    };
  }
}

interface ValidationResult {
  valid: boolean;
  errors: string[];
  payload?: JWTPayload;
}


// JWT attack payloads generator
const generateAttackPayloads = (): Array<{ name: string; token: string; description: string }> => {
  const attacks: Array<{ name: string; token: string; description: string }> = [];

  // Algorithm None attack
  const noneHeader = base64UrlEncode(JSON.stringify({ alg: 'none', typ: 'JWT' }));
  const payload = base64UrlEncode(JSON.stringify({
    sub: 'admin',
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 3600,
    role: 'admin'
  }));
  attacks.push({
    name: 'Algorithm None',
    token: `${noneHeader}.${payload}.`,
    description: 'Attempts to bypass signature verification using alg:none'
  });

  // Algorithm confusion (RS256 -> HS256)
  const hs256Header = base64UrlEncode(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
  attacks.push({
    name: 'Algorithm Confusion',
    token: `${hs256Header}.${payload}.fake_signature`,
    description: 'Attempts to use public key as HMAC secret'
  });

  // Empty signature
  const rs256Header = base64UrlEncode(JSON.stringify({ alg: 'RS256', typ: 'JWT' }));
  attacks.push({
    name: 'Empty Signature',
    token: `${rs256Header}.${payload}.`,
    description: 'Token with empty signature'
  });

  // Expired token
  const expiredPayload = base64UrlEncode(JSON.stringify({
    sub: 'user',
    iat: Math.floor(Date.now() / 1000) - 7200,
    exp: Math.floor(Date.now() / 1000) - 3600
  }));
  attacks.push({
    name: 'Expired Token',
    token: `${rs256Header}.${expiredPayload}.signature`,
    description: 'Token that has already expired'
  });

  // Future token
  const futurePayload = base64UrlEncode(JSON.stringify({
    sub: 'user',
    iat: Math.floor(Date.now() / 1000) + 3600,
    exp: Math.floor(Date.now() / 1000) + 7200
  }));
  attacks.push({
    name: 'Future Token',
    token: `${rs256Header}.${futurePayload}.signature`,
    description: 'Token issued in the future'
  });

  // SQL injection in claims
  const sqlPayload = base64UrlEncode(JSON.stringify({
    sub: "admin'--",
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 3600
  }));
  attacks.push({
    name: 'SQL Injection in Claims',
    token: `${rs256Header}.${sqlPayload}.signature`,
    description: 'SQL injection attempt in subject claim'
  });

  return attacks;
};

// JWT claim injection detector
const detectClaimInjection = (payload: JWTPayload): string[] => {
  const issues: string[] = [];
  const dangerousPatterns = [
    /['";].*(--)|(\/\*)/i,  // SQL injection
    /<script/i,             // XSS
    /\$\{.*\}/,            // Template injection
    /{{.*}}/,              // Template injection
    /\beval\b/i,           // Code injection
    /\bexec\b/i,           // Command injection
  ];

  const checkValue = (key: string, value: unknown): void => {
    if (typeof value === 'string') {
      dangerousPatterns.forEach(pattern => {
        if (pattern.test(value)) {
          issues.push(`Suspicious pattern in claim "${key}": ${value}`);
        }
      });
    } else if (typeof value === 'object' && value !== null) {
      Object.entries(value).forEach(([k, v]) => checkValue(`${key}.${k}`, v));
    }
  };

  Object.entries(payload).forEach(([key, value]) => checkValue(key, value));

  return issues;
};


describe('JWT Security Tests', () => {
  describe('Algorithm Validation', () => {
    let validator: SecureJWTValidator;

    beforeEach(() => {
      validator = new SecureJWTValidator({
        issuer: 'https://auth.hsdcore.com',
        audience: 'hsd-api'
      });
    });

    it('should reject "none" algorithm', () => {
      const header = base64UrlEncode(JSON.stringify({ alg: 'none', typ: 'JWT' }));
      const payload = base64UrlEncode(JSON.stringify({
        sub: 'admin',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 3600,
        iss: 'https://auth.hsdcore.com',
        aud: 'hsd-api'
      }));
      const token = `${header}.${payload}.`;

      const result = validator.validate(token);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('none'))).toBe(true);
    });

    it('should reject symmetric algorithms (algorithm confusion)', () => {
      const header = base64UrlEncode(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
      const payload = base64UrlEncode(JSON.stringify({
        sub: 'user',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 3600,
        iss: 'https://auth.hsdcore.com',
        aud: 'hsd-api'
      }));
      const token = `${header}.${payload}.fake_signature`;

      const result = validator.validate(token);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('Symmetric algorithms'))).toBe(true);
    });

    it('should accept allowed asymmetric algorithms', () => {
      const allowedAlgs = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'];
      
      allowedAlgs.forEach(alg => {
        const header = base64UrlEncode(JSON.stringify({ alg, typ: 'JWT' }));
        const payload = base64UrlEncode(JSON.stringify({
          sub: 'user',
          iat: Math.floor(Date.now() / 1000),
          exp: Math.floor(Date.now() / 1000) + 3600,
          iss: 'https://auth.hsdcore.com',
          aud: 'hsd-api'
        }));
        const token = `${header}.${payload}.valid_signature`;

        const result = validator.validate(token);
        // Should not have algorithm-related errors
        expect(result.errors.some(e => e.includes('Algorithm'))).toBe(false);
      });
    });
  });

  describe('Token Expiration', () => {
    let validator: SecureJWTValidator;

    beforeEach(() => {
      validator = new SecureJWTValidator({
        issuer: 'https://auth.hsdcore.com',
        audience: 'hsd-api'
      });
    });

    it('should reject expired tokens', () => {
      const header = base64UrlEncode(JSON.stringify({ alg: 'RS256', typ: 'JWT' }));
      const payload = base64UrlEncode(JSON.stringify({
        sub: 'user',
        iat: Math.floor(Date.now() / 1000) - 7200,
        exp: Math.floor(Date.now() / 1000) - 3600, // Expired 1 hour ago
        iss: 'https://auth.hsdcore.com',
        aud: 'hsd-api'
      }));
      const token = `${header}.${payload}.signature`;

      const result = validator.validate(token);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('expired'))).toBe(true);
    });

    it('should reject tokens issued in the future', () => {
      const header = base64UrlEncode(JSON.stringify({ alg: 'RS256', typ: 'JWT' }));
      const payload = base64UrlEncode(JSON.stringify({
        sub: 'user',
        iat: Math.floor(Date.now() / 1000) + 3600, // 1 hour in future
        exp: Math.floor(Date.now() / 1000) + 7200,
        iss: 'https://auth.hsdcore.com',
        aud: 'hsd-api'
      }));
      const token = `${header}.${payload}.signature`;

      const result = validator.validate(token);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('future'))).toBe(true);
    });
  });


  describe('Issuer and Audience Validation', () => {
    let validator: SecureJWTValidator;

    beforeEach(() => {
      validator = new SecureJWTValidator({
        issuer: 'https://auth.hsdcore.com',
        audience: 'hsd-api'
      });
    });

    it('should reject tokens with wrong issuer', () => {
      const header = base64UrlEncode(JSON.stringify({ alg: 'RS256', typ: 'JWT' }));
      const payload = base64UrlEncode(JSON.stringify({
        sub: 'user',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 3600,
        iss: 'https://evil.com',
        aud: 'hsd-api'
      }));
      const token = `${header}.${payload}.signature`;

      const result = validator.validate(token);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('Invalid issuer'))).toBe(true);
    });

    it('should reject tokens with wrong audience', () => {
      const header = base64UrlEncode(JSON.stringify({ alg: 'RS256', typ: 'JWT' }));
      const payload = base64UrlEncode(JSON.stringify({
        sub: 'user',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 3600,
        iss: 'https://auth.hsdcore.com',
        aud: 'other-api'
      }));
      const token = `${header}.${payload}.signature`;

      const result = validator.validate(token);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('Invalid audience'))).toBe(true);
    });
  });

  describe('Replay Attack Prevention', () => {
    let validator: SecureJWTValidator;

    beforeEach(() => {
      validator = new SecureJWTValidator({
        issuer: 'https://auth.hsdcore.com',
        audience: 'hsd-api'
      });
    });

    it('should detect token replay', () => {
      const jti = crypto.randomUUID();
      const header = base64UrlEncode(JSON.stringify({ alg: 'RS256', typ: 'JWT' }));
      const payload = base64UrlEncode(JSON.stringify({
        sub: 'user',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 3600,
        iss: 'https://auth.hsdcore.com',
        aud: 'hsd-api',
        jti
      }));
      const token = `${header}.${payload}.signature`;

      // First use should pass (ignoring signature for this test)
      validator.validate(token);

      // Second use should detect replay
      const result = validator.validate(token);
      expect(result.errors.some(e => e.includes('replay'))).toBe(true);
    });
  });

  describe('Attack Payload Detection', () => {
    let validator: SecureJWTValidator;

    beforeEach(() => {
      validator = new SecureJWTValidator({
        issuer: 'https://auth.hsdcore.com',
        audience: 'hsd-api'
      });
    });

    it('should reject all known attack payloads', () => {
      const attacks = generateAttackPayloads();

      attacks.forEach(attack => {
        const result = validator.validate(attack.token);
        expect(result.valid).toBe(false);
      });
    });
  });

  describe('Claim Injection Detection', () => {
    it('should detect SQL injection in claims', () => {
      const payload: JWTPayload = {
        sub: "admin'--",
        iat: Date.now(),
        exp: Date.now() + 3600000
      };

      const issues = detectClaimInjection(payload);
      expect(issues.length).toBeGreaterThan(0);
    });

    it('should detect XSS in claims', () => {
      const payload: JWTPayload = {
        sub: 'user',
        iat: Date.now(),
        exp: Date.now() + 3600000,
        name: '<script>alert("xss")</script>'
      };

      const issues = detectClaimInjection(payload);
      expect(issues.length).toBeGreaterThan(0);
    });

    it('should detect template injection', () => {
      const payload: JWTPayload = {
        sub: 'user',
        iat: Date.now(),
        exp: Date.now() + 3600000,
        data: '${process.env.SECRET}'
      };

      const issues = detectClaimInjection(payload);
      expect(issues.length).toBeGreaterThan(0);
    });

    it('should pass clean payloads', () => {
      const payload: JWTPayload = {
        sub: 'user123',
        iat: Date.now(),
        exp: Date.now() + 3600000,
        name: 'John Doe',
        email: 'john@example.com'
      };

      const issues = detectClaimInjection(payload);
      expect(issues.length).toBe(0);
    });
  });


  describe('Token Format Validation', () => {
    let validator: SecureJWTValidator;

    beforeEach(() => {
      validator = new SecureJWTValidator({
        issuer: 'https://auth.hsdcore.com',
        audience: 'hsd-api'
      });
    });

    it('should reject malformed tokens', () => {
      const malformedTokens = [
        'not.a.valid.token.format',
        'only.two.parts',
        'single_part',
        '',
        '...',
        'header.payload.',
        '.payload.signature'
      ];

      malformedTokens.forEach(token => {
        const result = validator.validate(token);
        expect(result.valid).toBe(false);
      });
    });

    it('should reject invalid base64 encoding', () => {
      const token = 'invalid!!!.base64!!!.encoding!!!';
      const result = validator.validate(token);
      expect(result.valid).toBe(false);
    });

    it('should reject invalid JSON in header', () => {
      const invalidHeader = base64UrlEncode('not json');
      const payload = base64UrlEncode(JSON.stringify({ sub: 'user' }));
      const token = `${invalidHeader}.${payload}.signature`;

      const result = validator.validate(token);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('Invalid header'))).toBe(true);
    });

    it('should reject invalid JSON in payload', () => {
      const header = base64UrlEncode(JSON.stringify({ alg: 'RS256', typ: 'JWT' }));
      const invalidPayload = base64UrlEncode('not json');
      const token = `${header}.${invalidPayload}.signature`;

      const result = validator.validate(token);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('Invalid payload'))).toBe(true);
    });
  });

  describe('Property-Based JWT Tests', () => {
    it('should always reject tokens with "none" algorithm regardless of payload', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 50 }),
          fc.integer({ min: 0, max: 1000000 }),
          (subject, expOffset) => {
            const validator = new SecureJWTValidator({
              issuer: 'https://auth.hsdcore.com',
              audience: 'hsd-api'
            });

            const header = base64UrlEncode(JSON.stringify({ alg: 'none', typ: 'JWT' }));
            const payload = base64UrlEncode(JSON.stringify({
              sub: subject,
              iat: Math.floor(Date.now() / 1000),
              exp: Math.floor(Date.now() / 1000) + expOffset,
              iss: 'https://auth.hsdcore.com',
              aud: 'hsd-api'
            }));
            const token = `${header}.${payload}.`;

            const result = validator.validate(token);
            expect(result.valid).toBe(false);
          }
        ),
        { numRuns: 50 }
      );
    });

    it('should always reject expired tokens', () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 60, max: 86400 }), // 1 minute to 1 day ago
          (secondsAgo) => {
            const validator = new SecureJWTValidator({
              issuer: 'https://auth.hsdcore.com',
              audience: 'hsd-api'
            });

            const header = base64UrlEncode(JSON.stringify({ alg: 'RS256', typ: 'JWT' }));
            const payload = base64UrlEncode(JSON.stringify({
              sub: 'user',
              iat: Math.floor(Date.now() / 1000) - secondsAgo - 3600,
              exp: Math.floor(Date.now() / 1000) - secondsAgo,
              iss: 'https://auth.hsdcore.com',
              aud: 'hsd-api'
            }));
            const token = `${header}.${payload}.signature`;

            const result = validator.validate(token);
            expect(result.errors.some(e => e.includes('expired'))).toBe(true);
          }
        ),
        { numRuns: 50 }
      );
    });
  });

  describe('Key Confusion Attacks', () => {
    it('should not allow using public key as HMAC secret', () => {
      const validator = new SecureJWTValidator({
        issuer: 'https://auth.hsdcore.com',
        audience: 'hsd-api'
      });

      // Attacker tries to sign with public key using HS256
      const header = base64UrlEncode(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
      const payload = base64UrlEncode(JSON.stringify({
        sub: 'admin',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 3600,
        iss: 'https://auth.hsdcore.com',
        aud: 'hsd-api',
        role: 'admin'
      }));
      const token = `${header}.${payload}.forged_signature`;

      const result = validator.validate(token);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('Symmetric algorithms'))).toBe(true);
    });
  });
});
